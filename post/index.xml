<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on TcpCat</title><link>http://tcp.cat/post/</link><description>Recent content in Posts on TcpCat</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Nov 2020 02:16:00 +0800</lastBuildDate><atom:link href="http://tcp.cat/post/index.xml" rel="self" type="application/rss+xml"/><item><title>使用docker部署rsshub</title><link>http://tcp.cat/post/docker%E9%83%A8%E7%BD%B2rsshub/</link><pubDate>Thu, 19 Nov 2020 02:16:00 +0800</pubDate><guid>http://tcp.cat/post/docker%E9%83%A8%E7%BD%B2rsshub/</guid><description>首先是docker compose 具体步骤可以参考rsshub文档，总之使用docker compose一把梭就OK啦。
先下载docker-compose.yml weget https://raw.githubusercontent.com/DIYgod/RSSHub/master/docker-compose.yml 这里可以先根据个人喜好配置一下docker-compose.yml的环境变量：
services: rsshub: ...... environment: # 因为部署在共网上，还是不要debug信息了。注意false的引号... DEBUG_INFO: &amp;quot;false&amp;quot; ACCESS_KEY: ILoveRSSHub ...... 然后是持久化redis docker volume create redis-data 接着就可以run起来 docker-compose up -d 然后是用Nginx反向代理 首先先找到rsshub在docker容器的ip地址，这里用的是docker inspect，rsshub_rsshub_1是rsshub在docker的名称，用容器ID也行，它们需要根据实际情况更改，可以用docker ps找到。
docker inspect rsshub_rsshub_1 | grep IPAddress &amp;gt;&amp;gt;&amp;gt; &amp;quot;SecondaryIPAddresses&amp;quot;: null, &amp;quot;IPAddress&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;IPAddress&amp;quot;: &amp;quot;172.19.0.4&amp;quot;, 额，这结果看起来不是那么优雅，所以还可以这样：
docker inspect --format='{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq) &amp;gt;&amp;gt;&amp;gt; /rsshub_rsshub_1 - 172.19.0.4 /rsshub_browserless_1 - 172.19.0.3 /rsshub_redis_1 - 172.</description></item><item><title>Median Of Two Sorted Arrays</title><link>http://tcp.cat/post/medianoftwosortedarrays/</link><pubDate>Mon, 23 Mar 2020 22:41:55 +0800</pubDate><guid>http://tcp.cat/post/medianoftwosortedarrays/</guid><description>复习 &amp;ndash; Binary Search # 参考python源码bisect.py, 返回值为第一个不小于val的值的索引. def lower_bound(array, val): low = 0 high = len(array) while low &amp;lt; high: mid = low + (high - low) // 2 if array[mid] &amp;lt; val: low = mid + 1 else: high = mid return low Notes:
算法搜索区间为[low, high), 为了保证这个搜索区间: high的初始值为len(array), 而不是len(array)-1 循环的判断使用&amp;lt;, 而不是&amp;lt;=. 若使用while(low &amp;lt;= high)将搜索空间扩展为[low, high], 最后会导致无限循环. 更新low使用mid + 1, 而不是mid 不能使用array[mid] == val来判断是否终止循环. 当array存在重复元素, 这时返回的值可能不是第一个不小于val的索引.但如果只是为了找到任意一个满足条件的索引则可以这样做. 以上代码使用与非降序排列的数组.</description></item><item><title>使用github action和Firebase搭配来托管博客</title><link>http://tcp.cat/post/%E4%BD%BF%E7%94%A8github-action%E5%92%8Cfirebase%E6%90%AD%E9%85%8D%E6%9D%A5%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2/</link><pubDate>Sat, 22 Feb 2020 02:16:00 +0800</pubDate><guid>http://tcp.cat/post/%E4%BD%BF%E7%94%A8github-action%E5%92%8Cfirebase%E6%90%AD%E9%85%8D%E6%9D%A5%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2/</guid><description>絮絮叨叨 考虑到个人博客的流量不会很大(应该是除了自己基本没有( &amp;gt;﹏&amp;lt;。)),使用vps的话就太麻烦了.自己首先弄好linux环境,然后要配置nginx或者Apache之类的,之后是申请SSL证书,解析DNS&amp;hellip;虽然步骤也不是很多,但是万一VPS就被DDOS了呢,就被hack了呢&amp;hellip;其实不用vps最主要原因是&amp;hellip;穷´_&amp;gt;` 正经说来,搭建个人博客这种静态网站的主要工作有:
选择白嫖的服务器,国外的服务器可以用Github Pages, Google的Firebase,Netfly etc..如果域名有备案的话,可以使用七牛的对象存储,每月10G的免费流量. 腾讯云cos新用户只免费6个月了.其实买的话也挺便宜,流量不多每个月也就几块钱.但我懒得备案了就用了Firebase,国内访问似乎还行. 然后就是把域名解析到服务器上.现在用的是Cloudflare管理dns解析.现在Github Pages支持HTTPS了,Firebase也行.直接根据提示解析过去就行. 假如托管在VPS上,可以自己申请Let&amp;rsquo;sEncrypt的证书,然后要在Nginx或Apache上设置好https的路由. 选择一个静态博客生成器,Jekyll/Hexo/Hugo/etc&amp;hellip;其实用哪个都没所谓,保存好自己的markdown文件,然后哪个有心仪的主题就用哪个.甚至都可以自己写一个,解析markdown到HTML,再折腾出一套css就ok了. 将hugo或其他生成器生成的静态网站内容推送到托管的服务器上面,一般是public文件夹里面的内容. 最后建议设置一个闹钟每天提醒写博客,不然只有域名或vps续费的时候才会想起来自己居然还有个博客¯\_(ツ)_/¯ 使用Google Firebase托管博客 使用firebase的原因很简单:
免费 国内暂时还能访问(Firebase官网还是要梯子╮(￣▽￣)╭) 能自定义域名 申请Firebase帐号时,记得选择Spark类型账户.申请完之后创建一个类型为Hosting的新项目.可以使用firebase-cli将本地文件夹推送到服务器上. curl -sL firebase.tools | bash #安装firebase-cli firebase login #完成本地登录 cd $BLOG #切换到自己的博客文件夹 firebase init 执行firebase init时会询问托管类型,因为是博客,选择Hosting就行啦.然后会有这么一个问题
? What do you want to use as your public directory? (public) Hugo的生成的静态网站就在public文件夹下,因此默认回车就行.有的则是在dist等其他文件夹下,别填错了.错了也没关系,在firebase.json里改就行. 然后接下来执行
firebase login:ci 这会生成一个TOKEN,在github action自动推送到firebase里会用到,记得保存在Github Repo里的Settings -&amp;gt;Secrets', 假如保存的名字为FIREBASE_TOKEN,那么github action`可以直接读取.
${{ secrets.FIREBASE_TOKEN }} 至此和Firebase相关的工作就都完成了,deploy的步骤会交给github action来完成.
使用Github Action来构建博客 因为有了Github Action这种工具,什么安装Hugo, Hexo,Nodejs,yarn环境什么的,本地电脑可以完全不考虑,新建好文件夹保存markdown即可.</description></item><item><title>Hello</title><link>http://tcp.cat/post/hello/</link><pubDate>Wed, 19 Feb 2020 17:25:47 +0800</pubDate><guid>http://tcp.cat/post/hello/</guid><description>Firebase Test this is a test post.</description></item><item><title/><link>http://tcp.cat/post/http.server%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://tcp.cat/post/http.server%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>http.server代码阅读 python内置一个简单的web server，可以用 python -m http.server 直接调用。直接调用运行的server是单线程的，而且只接受HTTP的GET和HEAD方法，若要使用POST等方法就要自己手动扩展了。源码在此 https://github.com/python/cpython/blob/master/Lib/http/server.py
代码结构很清晰，用pyrevese生成的类图如下，可以看出整个module大致分为两个部分，server类和处理http请求的handler类。 main function main函数主要负责直接使用python -m的执行。首先使用argparse解析传入的参数。 module是支持cgi扩展的，如果传入的参数有cgi的需求则使用CGIHTTPRequestHandler来处理，其它则用SimpleHTTPRequestHandler处理。test()函数使用解析后的参数来让server运行起来。 HTTP请求处理 HTTP请求处理包括三个类，BaseHTTPRequestHandler SimpleHTTPRequestHandler 和 CGIHTTPResquestHandler。
BaseHTTPRequestHandler 这个类实现的是对HTTP请求的基本处理。HTTP(HyperText Transfer Protocol)是一个建立在可靠数据流传输服务（例如TCP/IP）之上的可扩展协议。该协议会识别出HTTP请求的三个部分：
一行用于验证请求类型和路径的部分 可选的RFC-822-style headers 可选的data 其中headers和数据使用一个空行分隔。 http请求的第一行格式为 &amp;lt;command&amp;gt; &amp;lt;path&amp;gt; &amp;lt;version&amp;gt; 其中 &amp;lt;command&amp;gt;是一个大小写敏感的关键字，例如GET和POST；path是包含路径信息的字符串，使用URL编码规则进行编码。；version表示HTTP协议版本，例如HTTP/1.0或者HTTP/1.1，要注意的是版本号的格式为1.x，后面小数不可省略。 HTTP规定了使用CRLF进行换行，但为了兼容性的考虑，也需要处理LF换行的情况。http请求中的空格也需要相似的处理（允许相邻部分存在多个空格，也允许末尾存在空格）。 同样地，对于服务器的输出，应当使用CRLF换行，但是也要保证兼容LF换行。 如果请求的第一行格式不包括version，则默认为0.9，这种格式的请求没有headers和data部分，服务器的响应也只有data部分。 对于HTTP/1.x协议，服务器响应也由三部分组成：
第一行给出响应的状态码
一组可选的RFC-822-style headers
data
其中headers和data也用空行分隔。
http状态码的格式为 &amp;lt;version&amp;gt; &amp;lt;responsecode&amp;gt; &amp;lt;responsestring&amp;gt; 其中&amp;lt;version&amp;gt;仍然表示http版本（HTTP/1.0或者HTTP/1.1）；&amp;lt;responsecode&amp;gt;是三个数字组成的HTTP状态码（例如200，500），用于表明请求是否成功；&amp;lt;responsestring&amp;gt;为面向用户的可选字符串，用于解释状态码含义。 python内置的server的主要工作是解析http请求及其headers，然后根据请求类型（GET或POST）调用相关的函数处理该请求。需要指出的是，若请求被识别为SPAM，则调用do_SPAM()方法处理，如果没有该方法，server则返回一个错误响应。
实例变量中会存储http请求的细节：
client_address为客户端的ip地址，格式为(host, port) command, path, version是处理过后的请求行 headers是email.message.Message类的实例，带有header信息 rfile是一个可读的文件对象，位于可选data部分的开始，来自socketserver wfile是一个可写的文件对象，来之socketserver 根据HTTP协议，响应内容的第一行必须给出响应状态。然后是0行或者多行header。然后是一个空行。再然后才是data。header行的内容由server所执行的命令有关，在大多数情况下，如果有data返回，则header应当至少有一行包括Content-type: &amp;lt;type&amp;gt;/&amp;lt;subtype&amp;gt;，type和subtype为MIME类型，例如text/html或者text/plain。</description></item></channel></rss>