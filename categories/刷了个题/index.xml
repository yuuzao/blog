<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>刷了个题 on TcpCat</title><link>http://tcp.cat/categories/%E5%88%B7%E4%BA%86%E4%B8%AA%E9%A2%98/</link><description>Recent content in 刷了个题 on TcpCat</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 23 Mar 2020 22:41:55 +0800</lastBuildDate><atom:link href="http://tcp.cat/categories/%E5%88%B7%E4%BA%86%E4%B8%AA%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>Median Of Two Sorted Arrays</title><link>http://tcp.cat/post/medianoftwosortedarrays/</link><pubDate>Mon, 23 Mar 2020 22:41:55 +0800</pubDate><guid>http://tcp.cat/post/medianoftwosortedarrays/</guid><description>复习 &amp;ndash; Binary Search # 参考python源码bisect.py, 返回值为第一个不小于val的值的索引. def lower_bound(array, val): low = 0 high = len(array) while low &amp;lt; high: mid = low + (high - low) // 2 if array[mid] &amp;lt; val: low = mid + 1 else: high = mid return low Notes:
算法搜索区间为[low, high), 为了保证这个搜索区间: high的初始值为len(array), 而不是len(array)-1 循环的判断使用&amp;lt;, 而不是&amp;lt;=. 若使用while(low &amp;lt;= high)将搜索空间扩展为[low, high], 最后会导致无限循环. 更新low使用mid + 1, 而不是mid 不能使用array[mid] == val来判断是否终止循环. 当array存在重复元素, 这时返回的值可能不是第一个不小于val的索引.但如果只是为了找到任意一个满足条件的索引则可以这样做. 以上代码使用与非降序排列的数组.</description></item></channel></rss>